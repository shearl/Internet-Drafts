<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
   <head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>EZFLATE: Token-based DEFLATE Compression</title><script>
var buttonsAdded = false;

function initFeedback() {
  var fb = document.createElement("div");
  fb.className = "feedback noprint";
  fb.setAttribute("onclick", "feedback();");
  fb.appendChild(document.createTextNode("feedback"));

  var bodyl = document.getElementsByTagName("body");
  bodyl.item(0).appendChild(fb);
}

function feedback() {
  toggleButtonsToElementsByName("h1");
  toggleButtonsToElementsByName("h2");
  toggleButtonsToElementsByName("h3");
  toggleButtonsToElementsByName("h4");

  buttonsAdded = !buttonsAdded;
}

function toggleButtonsToElementsByName(name) {
  var list = document.getElementsByTagName(name);
  for (var i = 0; i < list.length; i++) {
    toggleButton(list.item(i));
  }
}

function toggleButton(node) {
  if (! buttonsAdded) {

    // docname
    var template = "mailto:k.morgan@iaea.org?subject={docname},%20%22{section}%22&body=<{ref}>:";

    var id = node.getAttribute("id");
    // better id available?
    var titlelinks = node.getElementsByTagName("a");
    for (var i = 0; i < titlelinks.length; i++) {
      var tl = titlelinks.item(i);
      if (tl.getAttribute("id")) {
        id = tl.getAttribute("id");
      }
    }

    // ref
    var ref = window.location.toString();
    var hash = ref.indexOf("#");
    if (hash != -1) {
      ref = ref.substring(0, hash);
    }
    if (id != "") {
      ref += "#" + id;
    }

    // docname
    var docname = "draft-morgan-ezflate-latest";

    // section
    var section = node.textContent;
    section = section.replace("\u00a0", " ");

    // build URI from template
    var uri = template.replace("{docname}", encodeURIComponent(docname));
    uri = uri.replace("{section}", encodeURIComponent(section));
    uri = uri.replace("{ref}", encodeURIComponent(ref));

    var button = document.createElement("a");
    button.className = "fbbutton noprint";
    button.setAttribute("href", uri);
    button.appendChild(document.createTextNode("send feedback"));
    node.appendChild(button);
  }
  else {
    var buttons = node.getElementsByTagName("a");
    for (var i = 0; i < buttons.length; i++) {
      var b = buttons.item(i);
      if (b.className == "fbbutton noprint") {
        node.removeChild(b);
      }
    }
  }
}</script><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: cambria, helvetica, arial, sans-serif;
  font-size: 11pt;
  margin-right: 2em;
}
cite {
  font-style: normal;
}
dl {
  margin-left: 2em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 130%;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h2 {
  font-size: 120%;
  line-height: 15pt;
  page-break-after: avoid;
}
h3 {
  font-size: 110%;
  page-break-after: avoid;
}
h4, h5, h6 {
  page-break-after: avoid;
}
h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
}
ol {
  margin-left: 2em;
}
ol.la {
  list-style-type: lower-alpha;
}
ol.ua {
  list-style-type: upper-alpha;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
  page-break-inside: avoid;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
sup {
  font-size: 60%;
}
table {
  margin-left: 2em;
}
table.header {
  border-spacing: 1px;
  width: 95%;
  font-size: 11pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap;
}
table.header td {
  background-color: gray;
  width: 50%;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc, ul.toc ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
}
ul.toc li {
  line-height: 150%;
  font-weight: bold;
  margin-left: 0em;
}
ul.toc li li {
  line-height: normal;
  font-weight: normal;
  font-size: 10pt;
  margin-left: 0em;
}
li.excluded {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}
.title, .filename, h1, h2, h3, h4 {
  font-family: candara, helvetica, arial, sans-serif;
}
samp, tt, code, pre {
  font: consolas, monospace;
}

.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 10pt;
}
.filename {
  color: #333333;
  font-size: 75%;
  font-weight: bold;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: green;
  font-size: 150%;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.warning {
  font-size: 130%;
  background-color: yellow;
}
.feedback {
  position: fixed;
  bottom: 1%;
  right: 1%;
  padding: 3px 5px;
  color: white;
  border-radius: 5px;
  background: #a00000;
  border: 1px solid silver;
}
.fbbutton {
  margin-left: 1em;
  color: #303030;
  font-size: small;
  font-weight: normal;
  background: #d0d000;
  padding: 1px 4px;
  border: 1px solid silver;
  border-radius: 5px;
}

@media print {
  .noprint {
    display: none;
  }

  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 110%;
  }

  ul.toc a:nth-child(2)::after {
    content: leader('.') target-counter(attr(href), page);
  }

  ul.ind li li a {
    content: target-counter(attr(href), page);
  }

  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "Internet-Draft";
  }
  @top-right {
       content: "June 2014";
  }
  @top-center {
       content: "EZFLATE";
  }
  @bottom-left {
       content: "Morgan & Brunhuber";
  }
  @bottom-center {
       content: "Expires December 4, 2014";
  }
  @bottom-right {
       content: "[Page " counter(page) "]";
  }
}

@page:first {
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><style tyle="text/css">@viewport {   zoom: 1.0;   width: extend-to-zoom; }  @-ms-viewport {   width: extend-to-zoom;   zoom: 1.0; }  body {   font: 11pt cambria, helvetica, arial, sans-serif;   font-size-adjust: 0.5;   line-height: 130%;   margin: 1em auto;   max-width: 700px; }  .title, .filename, h1, h2, h3, h4 {   font-family: candara, helvetica, arial, sans-serif;   font-size-adjust: 0.5; } .title { font-size: 150%; } h1 { font-size: 130%; } h2 { font-size: 120%; } h3, h4 { font-size: 110%; } ul.toc >li { font-size: 95%; } ul.toc >li >ul, .figure, caption { font-size: 90%; }  table {   margin-left: 0em; } table.header {   width: 100%; }  table.header td {   background-color: inherit;   color: black; }  samp, tt, code, pre {   font: 11pt consolas, monospace;   font-size-adjust: none; }  pre.text, pre.text2 {   width: 90%; }  dt {   float: left; clear: left;   margin: 0.5em 0.5em 0 0; } dt:first-child {   margin-top: 0; } dd {   margin: 0.5em 0 0 2em; } dd p, dd ul {   margin-top: 0; margin-bottom: 0; } dd *+p {   margin-top: 0.5em; }  ol, ul {   padding: 0;   margin: 0.5em 0 0.5em 2em; } ul.toc, ul.toc ul {    margin: 0 0 0 1.5em; } ul.toc a:first-child {    display: inline-block;    min-width: 1.2em; }</style><link rel="Contents" href="#rfc.toc">
      <link rel="Author" href="#rfc.authors">
      <link rel="Copyright" href="#rfc.copyrightnotice">
      <link rel="Chapter" title="1 Introduction" href="#rfc.section.1">
      <link rel="Chapter" title="2 Compression Attacks" href="#rfc.section.2">
      <link rel="Chapter" title="3 Tokenization" href="#rfc.section.3">
      <link rel="Chapter" title="4 EZFLATE Compression Algorithm Details" href="#rfc.section.4">
      <link rel="Chapter" title="5 Security Considerations" href="#rfc.section.5">
      <link rel="Chapter" title="6 Acknowledgements" href="#rfc.section.6">
      <link rel="Chapter" href="#rfc.section.7" title="7 References">
      <meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.629, 2014/04/17 09:22:01, XSLT vendor: SAXON 8.9.0.4 from Saxonica http://www.saxonica.com/">
      <meta name="keywords" content="Compression, Security">
      <link rel="schema.dct" href="http://purl.org/dc/terms/">
      <meta name="dct.creator" content="Morgan, K.">
      <meta name="dct.creator" content="Brunhuber, C.">
      <meta name="dct.identifier" content="urn:ietf:id:draft-morgan-ezflate-latest">
      <meta name="dct.issued" scheme="ISO8601" content="2014-06-02">
      <meta name="dct.abstract" content="This specification defines EZFLATE, a token-based DEFLATE compression algorithm for secure compression within encrypted communication channels.">
      <meta name="description" content="This specification defines EZFLATE, a token-based DEFLATE compression algorithm for secure compression within encrypted communication channels.">
   </head>
   <body onload="initFeedback();">
      <table class="header">
         <tbody>
            <tr>
               <td class="left">HTTPbis</td>
               <td class="right">K. Morgan</td>
            </tr>
            <tr>
               <td class="left">Internet-Draft</td>
               <td class="right">C. Brunhuber</td>
            </tr>
            <tr>
               <td class="left">Intended status: Standards Track</td>
               <td class="right">IAEA</td>
            </tr>
            <tr>
               <td class="left">Expires: December 4, 2014</td>
               <td class="right">June 2, 2014</td>
            </tr>
         </tbody>
      </table>
      <p class="title">EZFLATE: Token-based DEFLATE Compression<br><span class="filename">draft-morgan-ezflate-latest</span></p>
      <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
      <p>This specification defines EZFLATE, a token-based DEFLATE compression algorithm for secure compression within encrypted communication
         channels.
      </p>
      <h1 id="rfc.note.1"><a href="#rfc.note.1">Editorial Note (To be removed by RFC Editor)</a></h1>
      <p>Discussion of this draft takes place on the HTTPBIS working group mailing list (ietf-http-wg@w3.org), which is archived at &lt;<a href="http://lists.w3.org/Archives/Public/ietf-http-wg/">http://lists.w3.org/Archives/Public/ietf-http-wg/</a>&gt;.
      </p>
      <p>Working Group information can be found at &lt;<a href="http://tools.ietf.org/wg/httpbis/">http://tools.ietf.org/wg/httpbis/</a>&gt;;
      </p>
      <div id="rfc.status">
         <h1><a href="#rfc.status">Status of This Memo</a></h1>
         <p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
         <p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute
            working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.
         </p>
         <p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other
            documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work
            in progress”.
         </p>
         <p>This Internet-Draft will expire on December 4, 2014.</p>
      </div>
      <div id="rfc.copyrightnotice">
         <h1><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
         <p>Copyright © 2014 IETF Trust and the persons identified as the document authors. All rights reserved.</p>
         <p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights
            and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License
            text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified
            BSD License.
         </p>
      </div>
      <hr class="noprint">
      <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
      <ul class="toc">
         <li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a></li>
         <li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2">Compression Attacks</a><ul>
               <li><a href="#rfc.section.2.1">2.1</a>&nbsp;&nbsp;&nbsp;<a href="#crime">CRIME</a></li>
               <li><a href="#rfc.section.2.2">2.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.2">BREACH</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3">Tokenization</a><ul>
               <li><a href="#rfc.section.3.1">3.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1">"Take a Bite out of CRIME"</a></li>
               <li><a href="#rfc.section.3.2">3.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.2">Delimiters &amp; Tokenization Methods</a><ul>
                     <li><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.2.1">Method 1: Keep Delimiters as Separate Tokens</a></li>
                     <li><a href="#rfc.section.3.2.2">3.2.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.2.2">Method 2: Keep Delimiters with Preceding Token</a></li>
                     <li><a href="#rfc.section.3.2.3">3.2.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.2.3">Method 3: Keep Delimiters with Succeeding Token</a></li>
                  </ul>
               </li>
               <li><a href="#rfc.section.3.3">3.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.3">Tokenization Rules</a></li>
            </ul>
         </li>
         <li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#algorithm">EZFLATE Compression Algorithm Details</a></li>
         <li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#Security">Security Considerations</a></li>
         <li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6">Acknowledgements</a></li>
         <li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul>
               <li><a href="#rfc.section.7.1">7.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li>
               <li><a href="#rfc.section.7.2">7.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li>
            </ul>
         </li>
         <li><a href="#rfc.authors">Authors' Addresses</a></li>
      </ul>
      <div id="introduction">
         <h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h1>
         <p id="rfc.section.1.p.1">DEFLATE <a href="#DEFLATE"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[DEFLATE]</cite></a> is one of the most widely used compression mechanisms. It forms the basis of ZIP <a href="#ZIP"><cite title=".ZIP File Format Specification">[ZIP]</cite></a>, GZIP <a href="#GZIP"><cite title="GZIP file format specification version 4.3">[GZIP]</cite></a> and ZLIB <a href="#ZLIB"><cite title="ZLIB Compressed Data Format Specification version 3.3">[ZLIB]</cite></a>. However, DEFLATE poses a security vulnerability when messages comprised of secret and attacker-controlled data are delivered
            through a secure communication channel, as demonstrated by the CRIME <a href="#CRIME"><cite title="The CRIME Attack">[CRIME]</cite></a> and BREACH <a href="#BREACH"><cite title="BREACH: REVIVING THE CRIME ATTACK">[BREACH]</cite></a> attacks.
         </p>
         <p id="rfc.section.1.p.2">A key observation of the CRIME and BREACH attacks is that they exploited the DEFLATE <em>algorithm</em> as described in RFC 1951 <a href="#DEFLATE"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[DEFLATE]</cite></a>, not the DEFLATE <em>format</em> (also described in RFC 1951).
         </p>
         <p id="rfc.section.1.p.3">The first paragraph of Section 4, "Compression algorithm details", in RFC 1951 explicitly states that the "deflate" format
            is not tied to any particular algorithm. To quote, it says, "While it is the intent of this document to define the 'deflate'
            compressed data format without reference to any particular compression algorithm, the format is related to the compressed
            formats produced by LZ77 ... it is strongly recommended that the implementor of a compressor follow the general algorithm
            presented here ... [however] a compressor need not follow it in order to be compliant <a href="#DEFLATE"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[DEFLATE]</cite></a>."
         </p>
         <p id="rfc.section.1.p.4">This document describes EZFLATE, a token-based DEFLATE <em>algorithm</em>. The key feature of the EZFLATE algorithm (and primary difference to the algorithm described in RFC 1951), is that LZ77 &lt;length,
            backward distance&gt; tuples may only reference a duplicated token (octet string) occurring in a previous block, up to 32K input
            bytes before, if the current token exactly matches in length <em>and</em> octet values. In other words, LZ77 tuples must not reference partial matches, neither smaller nor longer, occurring in a previous
            block.
         </p>
      </div>
      <div>
         <h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;Compression Attacks
         </h1>
         <div id="crime">
            <h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a href="#crime">CRIME</a></h2>
            <p id="rfc.section.2.1.p.1">SPDY <a href="#SPDY"><cite title="SPDY Protocol">[SPDY]</cite></a> used DEFLATE <a href="#DEFLATE"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[DEFLATE]</cite></a> to compress redundant HTTP <a href="#HTTP-p1"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[HTTP-p1]</cite></a> headers. The CRIME <a href="#CRIME"><cite title="The CRIME Attack">[CRIME]</cite></a> attack exploited DEFLATE to guess secret information contained in the HTTP request headers (e.g. "Cookies"). Since DEFLATE
               looks for matches character-by-character, the attackers were able to guess the secret one character at a time. Each failed
               guess resulted in a compressed block of size n. Correct guesses resulted in a compressed block of size m &lt; n. For example,
               consider the following sample HTTP requests (taken from <a href="#CRIME"><cite title="The CRIME Attack">[CRIME]</cite></a>): 
            </p>
            <div id="rfc.figure.u.1"></div>
            <p>Attacker guesses the first character is 'a':</p><pre>GET /twid=a
Host: twitter.com
User-Agent: Chrome
Cookie: twid=secret
	    </pre><p> ... (more guesses) ... </p>
            <div id="rfc.figure.u.2"></div>
            <p>Attacker guesses the first character is 's':</p><pre>GET /twid=s
Host: twitter.com
User-Agent: Chrome
Cookie: twid=secret
	    </pre><p> After guessing 's' is the first character of the secret, the attacker sees a corresponding increase in compression (i.e. decrease
               in length) indicating the guess is correct. The procedure is repeated until the entire secret is revealed.
            </p>
            <p id="rfc.section.2.1.p.2">Although this is a brute-force attack of sorts, the average number of guesses required to extract a secret is considerably
               lower, and therefore tractable, thanks to being able to guess character by character. If the number of possible characters
               is 256, then on average it will require 128 guesses per character to make a correct guess. An n-character secret then only
               requires, on average, n * 128 guesses to discover the secret. For example, a 12-character secret requires 12 * 128 = 1,536
               guesses. In many cases the set of possible characters is smaller than 256, reducing the search space even more!
            </p>
         </div>
         <div>
            <h2 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;BREACH
            </h2>
            <p id="rfc.section.2.2.p.1">While CRIME exploited SPDY (and TLS compression too), BREACH <a href="#BREACH"><cite title="BREACH: REVIVING THE CRIME ATTACK">[BREACH]</cite></a> exploited compression of HTTP <em>response bodies</em>. The mechanism of BREACH is similar to CRIME with slightly different details, therefore a detailed review of BREACH will
               not be given here.
            </p>
         </div>
      </div>
      <div>
         <h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;Tokenization
         </h1>
         <div>
            <h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;"Take a Bite out of CRIME"
            </h2>
            <p id="rfc.section.3.1.p.1">Taking a "bite out of crime" requires more than a security dog named McGruff <a href="#MCGRUFF"><cite title="About McGruff">[MCGRUFF]</cite></a>. EZFLATE fights CRIME by using token matching, rather than character-by-character matching, to make the search space for
               an attacker equivalent to a full brute-force attack. At that point there are easier ways to execute the brute-force attack.
            </p>
            <p id="rfc.section.3.1.p.2">As stated in <a href="#introduction" title="Introduction">Section&nbsp;1</a>, the key feature of the the EZFLATE algorithm (and primary difference to the algorithm described in RFC 1951), is that LZ77
               &lt;length, backward distance&gt; tuples may only reference a duplicated token (octet string) if the current token and referenced
               token exactly match in length <em>and</em> octet values. By selecting appropriate tokenization rules, potential attackers are forced to guess n-character secrets n characters
               at a time rather than one character at a time. Taking the example from <a href="#crime" title="CRIME">Section&nbsp;2.1</a>, a 12-character secret has a search space of 2<sup>12 * 8</sup> = 2<sup>96</sup> = 79,228,162,514,264,337,593,543,950,336 possible secrets (of course, on average it would "only" take an attacker half that
               many guesses to discover the secret by brute force). Even a Base64-encoded 12-character secret has a search space of 64<sup>12</sup> = 4,722,366,482,869,645,213,696 possible secrets.
            </p>
         </div>
         <div>
            <h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;Delimiters &amp; Tokenization Methods
            </h2>
            <p id="rfc.section.3.2.p.1">The classic tokenization method splits an arbitrary-length octet string by a subset of octets that act as "delimiters". The
               result is typically a set of octet strings with the delimiter octets omitted.
            </p>
            <p id="rfc.section.3.2.p.2">In the likely case where full reconstruction of the original octet string is desired, the delimiters obviously cannot be omitted.
               There are three different choices, outlined below, for keeping the delimiters. Each has their advantages and disadvantages.
               The best method for a particular data type can be discovered by experimenting. Note also that a sequence of consecutive delimiters
               are treated as a single unit.
            </p>
            <div>
               <h3 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;Method 1: Keep Delimiters as Separate Tokens
               </h3>
               <p id="rfc.section.3.2.1.p.1">The first tokenization method simply keeps the delimiter(s) as separate tokens. For example, consider the following string
                  of ASCII text to be tokenized by white space and puncuation. 
               </p>
               <div id="rfc.figure.u.3"></div>
               <p>ASCII string to be tokenized:</p><pre>		"The quick; brown fox."
	      </pre><p> </p>
               <div id="rfc.figure.u.4"></div>
               <p>Resulting token set after Method 1:</p><pre>		{ "The", " ", "quick", "; ", "brown", " ", "fox", "." }
	      </pre></div>
            <div>
               <h3 id="rfc.section.3.2.2"><a href="#rfc.section.3.2.2">3.2.2</a>&nbsp;Method 2: Keep Delimiters with Preceding Token
               </h3>
               <p id="rfc.section.3.2.2.p.1">The second tokenization method keeps the delimiter(s) with the token which immediately precedes the delimiter(s). </p>
               <div id="rfc.figure.u.5"></div>
               <p>Resulting token set after Method 2:</p><pre>		{ "The ", "quick; ", "brown ", "fox." }
	      </pre></div>
            <div>
               <h3 id="rfc.section.3.2.3"><a href="#rfc.section.3.2.3">3.2.3</a>&nbsp;Method 3: Keep Delimiters with Succeeding Token
               </h3>
               <p id="rfc.section.3.2.3.p.1">The third tokenization method keeps the delimiter(s) with the token which immediately succeeds the delimiter(s). </p>
               <div id="rfc.figure.u.6"></div>
               <p>Resulting token set after Method 2:</p><pre>		{ "The", " quick", "; brown", " fox", "." }
	      </pre></div>
         </div>
         <div>
            <h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;Tokenization Rules
            </h2>
            <p id="rfc.section.3.3.p.1">Note that EZFLATE is agnostic to tokenization methods and delimiter sets. Appropriate tokenization rules and delimiter sets
               depend on the type of data to be compressed. For a particular data type, a global set of generally applicable tokenization
               rules ought to be selected if at all possible. This makes it easier for decompressors to verify, if desired, that the compressed
               data conforms to the rules and delimiter sets. However, specialized rules might be necessary for special cases, particularly
               cases which might negatively affect security. The selection of appropriate rules and delimiter sets for a particular data
               type is beyond the scope of this document.
            </p>
         </div>
      </div>
      <div id="algorithm">
         <h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#algorithm">EZFLATE Compression Algorithm Details</a></h1>
         <p id="rfc.section.4.p.1">The EZFLATE algorithm, described in this Section, is simply an alternate to the algorithm described in Section 4 of <a href="#DEFLATE"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[DEFLATE]</cite></a>, it is not intended to replace that algorithm, which provides better general-purpose compression.
         </p>
         <p id="rfc.section.4.p.2">The compressor MUST always operates on a single token (octet string). The compressor uses a chained hash table to find duplicated
            tokens. Any hash function may be used and the hash function may operate on the entire octet string or any subset. The compressor
            also uses a separate "length table" to track the token lengths for each position in the input window. At any given point during
            compression, let T be the next token at position P with length L (not necessarily all different octets, of course). First,
            the compressor computes the hash value of the token T and updates the hash table with the hash value of T and updates the
            "length table" with L at position P. Next, the compressor examines the hash chain for the token T. If the chain is empty,
            the compressor simply emits the L literal octets of T. If the hash chain is not empty, this indicates that the token T (or,
            if there was a hash collision, some other octet string with the same hash value) has occurred recently. The compressor follows
            the hash chain to find the first entry within the current window which has length L (stored in the length table) and is octet-for-octet
            equivalent to the L octets in T. If an exact match is found, the compressor may emit a LZ77 &lt;length, backward distance&gt; tuple,
            where the length is L and the backward distance is the position of the current token minus the position of the exactly matching
            token. If no exact match is found, the compressor simply emits the L literal octets of T.
         </p>
         <p id="rfc.section.4.p.3">Just as stated in Section 4 of <a href="#DEFLATE"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[DEFLATE]</cite></a>, "the compressor searches the hash chains starting with the most recent [octet] strings, to favor small distances and thus
            take advantage of the Huffman encoding <a href="#HUFF"><cite title="A Method for the Construction of Minimum Redundancy Codes">[HUFF]</cite></a>. The hash chains are singly linked. There are no deletions from the hash chains; the algorithm simply discards matches that
            are too old. To avoid a worst-case situation, very long hash chains are arbitrarily truncated at a certain length, determined
            by a run-time parameter."
         </p>
         <p id="rfc.section.4.p.4">To improve overall compression, the compressor may optionally defer emitting a match in order to find a longer match that
            is a consecutive sequence of matching tokens. After a set of one or more matches with positions Pm ... Pn have been found
            for the current token T1 at position P1 with length L1, the compressor may defer emitting the match and examine the next token
            T2 to determine if that token appears at any of the positions Pm + L1 ... Pn + L1, i.e. directly after any of the matches
            for T1. It is critical to note that the same rules apply for checking matches of T2 at positions Pm + L1 ... Pn + L1 as if
            the compressor were finding matches for T2 using the hash chain. In particular the length of a given token at position Pi
            + L1 must be equal to L2 <em>and</em> be octet-for-octet equivalent to the L2 octets in T2. The compressor reduces the set of matching positions in Pm ... Pn to
            only include those which had an exact match for T2 at a given position Pi + L1. If one or more matches remains, the process
            is repeated until either the set of deferred matches cannot be extended by the next token or the length of the next token
            is such that the overall length of the match would exceed the maximum length of a match (258 octets) allowed by the DEFLATE
            format (see Section 3.2.5 of <a href="#DEFLATE"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[DEFLATE]</cite></a>). Note that the compressor must keep enough information about the currently deferred match(es), that once the final match
            is found the total length and backward distance are known or can be computed. Once the set of matches cannot be extended any
            longer, the compressor returns to the normal process of searching for matches using the hash table.
         </p>
         <p id="rfc.section.4.p.5">Just as stated in Section 4 of <a href="#DEFLATE"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[DEFLATE]</cite></a>, "the compressor terminates a block when it determines that starting a new block with fresh trees would be useful, or when
            the block size fills up the compressor's block buffer."
         </p>
         <p id="rfc.section.4.p.6">A token T with length L less than the minimum length of a match (3 octets) allowed by the DEFLATE format (see Section 3.2.5
            of <a href="#DEFLATE"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[DEFLATE]</cite></a>) is processed by simply updating the "length table" and emiting the L literal octets. These short tokens should, however,
            participate in extending deferred matches. The same matching rules apply as for matching tokens in all other situations, namely
            the length of the potentially matching token stored in the "length table" must be equal to L and the L octets of the stored
            token must be octet-for-octet equivalent to the L octets in T.
         </p>
         <p id="rfc.section.4.p.7">Note that the formatting rules and static/dynamic Huffman encoding rules in RFC 1951 <a href="#DEFLATE"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[DEFLATE]</cite></a>, apply to any implementation of the EZFLATE algorithm described here.
         </p>
      </div>
      <div id="Security">
         <h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#Security">Security Considerations</a></h1>
         <p id="rfc.section.5.p.1">Care must be taken when implementing deferred matching such that checking for matches of the current token against the octets
            immediately following the deferred set of matches not only checks for octet equivalency, but length equivalency as well. If
            the length is not also checked, an attacker would be able to perform character-by-character guessing by injecting the token
            immediately preceding the secret, which in many cases may be a known identifier.
         </p>
         <p id="rfc.section.5.p.2">[TODO: A lot of the remaining text is completely lifted from the HPACK Internet Draft; re-write or give credit somehow.]</p>
         <p id="rfc.section.5.p.3">An EZFLATE compressor can still act as an oracle to an attacker probing the compression context. However, the attacker can
            only find out if the guess of the entire token is correct or not.
         </p>
         <p id="rfc.section.5.p.4">Still, an attacker could take advantage of this limited information for breaking low-entropy secrets using a brute-force attack.
            A server usually has some protections against such brute-force attack. Here, the attack would target the client, where it
            would be harder to detect. The attack would be even more dangerous if the attacker is able to prevent the traffic generated
            by its brute-force attack from reaching the server.
         </p>
         <p id="rfc.section.5.p.5">To offer protection against such type of attacks, users of an EZFLATE compressor SHOULD use non-compressed DEFLATE blocks
            (see Section 3.2.4 of <a href="#DEFLATE"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[DEFLATE]</cite></a>) disable compression of any low-entropy secrets which could be put at risk by a brute-force attack.
         </p>
         <p id="rfc.section.5.p.6">There is currently no known threat taking advantage of the use of a fixed Huffman encoding. A study has shown that using a
            fixed Huffman encoding table created an information leakage, however this same study concluded that an attacker could not
            take advantage of this information leakage to recover any meaningful amount of information (see <a href="#PETAL"><cite title="PETAL: Preset Encoding Table Information Leakage">[PETAL]</cite></a>).
         </p>
      </div>
      <div>
         <h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;Acknowledgements
         </h1>
         <p id="rfc.section.6.p.1">Roberto Peon and Hervé Ruellan.</p>
      </div>
      <h1 id="rfc.references"><a id="rfc.section.7" href="#rfc.section.7">7.</a> References
      </h1>
      <h2 id="rfc.references.1"><a href="#rfc.section.7.1" id="rfc.section.7.1">7.1</a> Normative References
      </h2>
      <table>
         <tr>
            <td class="reference"><b id="DEFLATE">[DEFLATE]</b></td>
            <td class="top">Deutsch, P., “<a href="http://tools.ietf.org/html/rfc1951">DEFLATE Compressed Data Format Specification version 1.3</a>”, RFC&nbsp;1951, May&nbsp;1996.
            </td>
         </tr>
      </table>
      <h2 id="rfc.references.2"><a href="#rfc.section.7.2" id="rfc.section.7.2">7.2</a> Informative References
      </h2>
      <table>
         <tr>
            <td class="reference"><b id="BREACH">[BREACH]</b></td>
            <td class="top">Gluck, Y., “<a href="http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf">BREACH: REVIVING THE CRIME ATTACK</a>”, July&nbsp;2013, &lt;<a href="http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf">http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf</a>&gt;.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="CRIME">[CRIME]</b></td>
            <td class="top">Rizzo, J. and T. Duong, “<a href="https://docs.google.com/a/twist.com/presentation/d/11eBmGiHbYcHR9gL5nDyZChu_-lCa2GizeuOfaLU2HOU/edit#slide=id.g1eb6c1b5_3_6">The CRIME Attack</a>”, September&nbsp;2012, &lt;<a href="https://docs.google.com/a/twist.com/presentation/d/11eBmGiHbYcHR9gL5nDyZChu_-lCa2GizeuOfaLU2HOU/edit#slide=id.g1eb6c1b5_3_6">https://docs.google.com/a/twist.com/presentation/d/11eBmGiHbYcHR9gL5nDyZChu_-lCa2GizeuOfaLU2HOU/edit#slide=id.g1eb6c1b5_3_6</a>&gt;.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="GZIP">[GZIP]</b></td>
            <td class="top">Deutsch, P., “<a href="http://tools.ietf.org/html/rfc1951">GZIP file format specification version 4.3</a>”, RFC&nbsp;1951, May&nbsp;1996.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HTTP-p1">[HTTP-p1]</b></td>
            <td class="top"><a href="mailto:fielding@gbiv.com" title="Adobe Systems Incorporated">Fielding, R., Ed.</a> and <a href="mailto:julian.reschke@greenbytes.de" title="greenbytes GmbH">J. Reschke, Ed.</a>, “<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-26">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-p1-messaging-26 (work in progress), February&nbsp;2014.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="HUFF">[HUFF]</b></td>
            <td class="top">Huffman, D., “<a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=4051119">A Method for the Construction of Minimum Redundancy Codes</a>”, Proceedings of the Institute of Radio Engineers&nbsp;Volume 40, Number 9, pp. 1098-1101, September&nbsp;1952, &lt;<a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=4051119">http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=4051119</a>&gt;.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="MCGRUFF">[MCGRUFF]</b></td>
            <td class="top">McGruff, M., “<a href="http://www.ncpc.org/about/about-mcgruff">About McGruff</a>”, 2014, &lt;<a href="http://www.ncpc.org/about/about-mcgruff">http://www.ncpc.org/about/about-mcgruff</a>&gt;.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="PETAL">[PETAL]</b></td>
            <td class="top">Tan, J. and J. Nahata, “<a href="http://www.pdl.cmu.edu/PDL-FTP/associated/CMU-PDL-13-106.pdf">PETAL: Preset Encoding Table Information Leakage</a>”, April&nbsp;2013, &lt;<a href="http://www.pdl.cmu.edu/PDL-FTP/associated/CMU-PDL-13-106.pdf">http://www.pdl.cmu.edu/PDL-FTP/associated/CMU-PDL-13-106.pdf</a>&gt;.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="SPDY">[SPDY]</b></td>
            <td class="top">Belshe, M. and R. Peon, “<a href="http://tools.ietf.org/html/draft-mbelshe-httpbis-spdy-00">SPDY Protocol</a>”, Internet-Draft&nbsp;draft-mbelshe-httpbis-spdy-00 (work in progress), February&nbsp;2012.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="ZIP">[ZIP]</b></td>
            <td class="top">Katz, P., “<a href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">.ZIP File Format Specification</a>”, September&nbsp;2012, &lt;<a href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">http://www.pkware.com/documents/casestudies/APPNOTE.TXT</a>&gt;.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="ZLIB">[ZLIB]</b></td>
            <td class="top">Deutsch, P., “<a href="http://tools.ietf.org/html/rfc1950">ZLIB Compressed Data Format Specification version 3.3</a>”, RFC&nbsp;1950, May&nbsp;1996.
            </td>
         </tr>
      </table>
      <div class="avoidbreak">
         <h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
         <p><b>Keith Shearl Morgan</b><br>
            	International Atomic Energy Agency
            <br>Email: <a href="mailto:k.morgan@iaea.org">k.morgan@iaea.org</a></p>
         <p><b>Christoph Brunhuber</b><br>
            	International Atomic Energy Agency
            <br>Email: <a href="mailto:c.brunhuber@iaea.org">c.brunhuber@iaea.org</a></p>
      </div>
   </body>
</html>